# Inherits the specified variable from the environment (from the parent
# process). By default no evironment variables are inherited.
env					DOMAIN_NAME;

# Defines user (and group) credentials use by worker processes.
user				nginx;

# Defines the number of CPU cores to be utilized (actual usage depends on other
# factors such as actual number of cores, number of hard disk drives etc.).
worker_processes	auto;

# -	Configures the default file for error logging.
# -	Logging to syslog can by configured with 'syslog:' and specifying the
# 	syslog domain name or IP address in 'server='.
# -	8 levels of logging can be set, starting from 'debug' (lowest) to 'emerg'
# 	(highest). Setting a certain level will cause all messages of the specified
# 	and more severe log levels to be logged.
error_log			syslog:server=rsyslog info;

# Used to set global options that affect how NGINX handles connection at a
# general level.
events {
	# Maximum number of simultaneous connections that can be opened by a worker
	# process.
	worker_connections	1024;
}

# Sets the configuration for HTTP connections.
http {
	# -	'include' includes another file into the configuration. The file should
	# 	consist syntatically correct directives and blocks.
	# -	The NGINX 'mime.types' consists of configuration that maps file name
	# 	extensions to MIME types of responses.
	include 		mime.types;

	# -	'default_type' defines the default MIME type of a response, in the case
	# 	where the type of file extension being dealt with is not defined in
	# 	'mime.types'.
	# -	The 'application/octet-stream' type treats the file as binary, and
	# 	usually browsers will download this sort of file rather than trying to
	# 	display it.
	default_type	application/octet-stream;

	# -	Specifies the log format (for access logs particularly).
	# -	'main' is just a name/reference for the format (see next directive).
	log_format		main '$remote_addr - $remote_user "$request" '
						 '$status $body_bytes_sent "$http_referer" '
						 '"$http_user_agent" "$http_x_forwarded_for"';

	# -	Sets the path, format, and configuration for a buffered log write.
	# -	Syslog can be configured similarly to 'error_log', with an additonal
	# 	parameter 'severity=' that defines the level of logging.
	# -	The format used here is 'main', referring to the previous directive.
	access_log 		syslog:server=rsyslog,severity=debug main;

	# Sendfile copies data between one FD and other from within the kernel,
	# which is more efficient than read() + write(). Default is off.
	sendfile		on;

	# Don't tell nginx version to the clients. Default is 'on'.
	server_tokens	off;

	# Sets configuration for a virtual server (Multiple servers require their
	# own block each).
	server {
		# - Sets the IP:Port or the path for a UNIX-domain socket on which the
		# 	server will accept request.
		# -	For an HTTPS server, the 'ssl' parameter must be specified after
		# 	the socket.
		# -	The 'default_server' sets the server as the default for the
		# 	specified IP:Port.
		listen						443 ssl default_server;

		# -	Enables the specified protocols.
		# -	In general, Transport Layer Security (TLS) provides encryption,
		# 	authentication, and integrity in HTTP connections.
		ssl_protocols				TLSv1.3;

		# Sets names for a virtual server.
		server_name					$DOMAIN_NAME www.$DOMAIN_NAME;

		# Specifies certificate to be used for initial authentication phase
		# during a TLS handshake. Certificate, including public key, of client
		# and server are exchanged during the handshake.
		ssl_certificate				/run/secrets/nginx-server.rsa.crt;

		# Specifies private key to be used in the middle of authentication
		# during a TLS handshake. It is used to decrypt the "premaster", which
		# was encrypted by the client using the server's public key obtained
		# from the SSL certificate.
		ssl_certificate_key			/run/secrets/nginx-server.rsa.key;

		# Specifies that our cipher suits should be preferred over client
		# ciphers. Default is 'off'.
		ssl_prefer_server_ciphers	on;

		# Sets the root directory for requests. When parsing requests, a file
		# path is constructed by merely adding a URI to the value of the root
		# direction (e.g. localhost/index.html => /var/www/html/index.html).
		root						/var/www/html/;

		# Enables the logging of rewrite-related processing results.
		rewrite_log					on;

		# -	Sets configuration depending on the URI.
		# -	Several prefixes ('=', '~', '~*', '^~') can be specified to match
		# 	with various cases of URI (in order of priority):
		#	  1) '='		: Exact match
		#	  2) '^~'		: Longest-prefix match (without regular expression)
		#	  4) '~' '~*'	: Regular expression match (case sensitive and
		# 					  insensitive)
		#	  3) none		: Longest-prefix match
		# - An '@' prefix can also be used to specify a named location, and
		#	this is used for request redirection than regular request
		# 	processing.
		location / {
			# Processes requests ending with '/', by appending the filenames
			# to the URI. The existence of files are checked in the specified
			# order. If no such files exist and:
			# 	1) The URI is not '/' (e.g. localhost/a/, example.com/a/), the
			# 	   first filename will be appended to the URI and passed on.
			# 	2) The URI is '/', no filename will be appended to the URI and
			# 	   so the original URI is passed on.
			# Otherwise, the URI with the first existing file appended will be
			# passed on.
			index	index.php index.html;
		}

		# Backward slash is to escape the '.' that would otherwise be
		# intepreted by regex.
		location ~* \.php$ {
			# -	Checks the existence of files or directories (with a '/' at the
			# 	end) in the specified order of URI (only one specified here,
			# 	'$uri') and uses the first found result for request processing
			# 	in the current context.
			# -	If there is no result a code can be returned. In this case, the
			# 	statement checks the existence of the PHP file before passing
			#	the request to the FastCGI server (below).
			try_files		$uri =404;

			# The NGINX 'fastcgi.conf' contains configuration necessary for the
			# PHP-FPM server. There is another file named 'fastcgi_params' that
			# is virtually the same as 'fastcgi.conf' except for one (or a few)
			# directives, and this file is more suitable for general FastCGI
			# applications.
			include			fastcgi.conf;

			# Sets the address of a FastCGI server for PHP requests to be
			# passed to (in this case).
			fastcgi_pass	wordpress-php:9000;
		}

		location = /adminer/ {
			# -	Changes the URI as specified in the second argument, based on
			#	the regular expression match in the first argument.
			# -	Single caret '^' specifies a "string anchor" that matches the
			# 	whole string in the regex pattern.
			# - Multiple 'rewrite' directives can exist in a single block and
			# 	they are executed sequentially in order of appearance.
			# - 'last' tells nginx to stop processing the current set of
			# 	rewrite-related directives and start a search for the new
			# 	location matching the changed URI.
			rewrite		^ /adminer last;
		}

		location = /adminer {
			# 'break' tells nginx to stop processing of the current set of
			# rewrite-related directives and continue the request processing in
			# the same location block.
			rewrite			^ /adminer.php break;

			include			fastcgi.conf;
			fastcgi_pass	adminer:8000;
		}

		# -	Caret '^' and dollar '$' are both string anchors which indicate
		# 	the start and end of the string that the regex pattern is applied
		# 	to.
		# -	Parentheses allow us to group part of the string together to be
		# 	considered in a regular expression. This also allows us to apply a
		# 	'quantifier' to the entire group or to restrict 'alternation' to
		# 	part of the regex.
		# -	In general, 'quantifiers' are metacharacters that specify the
		# 	number of occurences a character or group must be present for a
		# 	match to be found. E.g. question mark '?' is a 'greedy' quantifier
		# 	that matches 0 or 1 of the preceding token (i.e. trailing '/' can
		# 	be present or absent). 'Greedy' meaning the expression or group
		# 	will always be attempted to match unless the entire regular
		# 	expression fails. The opposite of greedy is 'lazy'.
		# -	'Alternation' enables "either/or" or conditonal matching in regular
		# 	expressions. E.g. vertical bar '|' allows us to match a single
		# 	regular expression out of several possible regular expressions
		# 	(i.e. 'status' or 'ping').
		# -	Regex target:
		# 		1) /wordpress/(status|ping)
		# 		2) /wordpress/(status|ping)/
		location ~ ^/wordpress/(status|ping)/?$ {
			# -	Dot '.' matches any single character except line break.
			# -	Asterisk '*' is a greedy quantifier like '?' but instead it
			# 	attempts to match the preceding token 0 or more (rather than
			# 	once) times.
			# - '*' and '?' together forms a lazy quantifier which tries to
			# 	match the preceding token ('.' here) zero or more times, as few
			# 	times as possible.
			# -	All in all this means that the expression will try to match:
			# 		1) '/wordpress/' => '/wordpress/' explicitly one-to-one
			# 		2) '(.*?)' => zero or more characters
			# 		3) trailing '/' => '/' zero or one trailing slash
			# -	$1 specifies capture groups in order.
			rewrite			^/wordpress/(.*?)/?$ /$1 break;

			include			fastcgi.conf;
			fastcgi_pass	wordpress-php:9001;
		}

		location ~ ^/adminer/(status|ping)/?$ {
			rewrite			^/adminer/(.*?)/?$ /$1 break;
			include			fastcgi.conf;
			fastcgi_pass	adminer:8001;
		}

		location ~ /realtime/? {
			rewrite	^ /status.html last;
		}

		location ~ /status.html/? {
			rewrite	^ /status.html break;
			root	/usr/share/php83/fpm/;
		}

		location ~ ^/(gitea|v2)($|/) {
			# Maximum allowed size of client request body to be proxied.
			client_max_body_size 512M;

			# - Make nginx use unescaped URI, keep "%2F" as-is and remove the
			#   "/gitea" sub-path prefix.
			# - $request_uri specifies the rest of the full path of URL/URI
			#   such as '/index.html' in 'foo.com/index.html'
			rewrite ^ $request_uri;
			rewrite ^/(gitea($|/))?(.*) /$3 break;

			# Sets the protocol and address of a proxied server and an optional
			# URI to which a location should be mapped.
			proxy_pass https://gitea:3000$uri;

			# - Allows redefining or appending fields of the request header
			#   passed to the proxied server.
			# - Variables starting with '$http_' are the headers specified in
			#   the request as they are, not processed by NGINX.
			# - $host specifies the hostname or domain name such as 'foo.com'.
			# - $remote_addr is the client addess.
			# - $scheme is the request scheme, either 'http' or 'https'.
			proxy_set_header Connection $http_connection;
			proxy_set_header Upgrade $http_upgrade;
			proxy_set_header Host $host;
			proxy_set_header X-Real-IP $remote_addr;
			proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
			proxy_set_header X-Forwarded-Proto $scheme;

			# When 'proxy_pass' value contains at least a variable, and the
			# address is specified as a domain name, the name is searched among
			# the described server groups. If not found among the groups (which
			# is true in this case), it is determined using a resolver. The
			# resolver specified here is Docker network's DNS resolver.
			resolver 127.0.0.11;
		}
	}

	# server {
	# 	listen		80 default_server;
	# 	server_name	$DOMAIN_NAME www.$DOMAIN_NAME;

	# 	# -	Stops processing and returns the specified code to the client.
	# 	# -	With code 301 (and several others such as 302, 307), it is
	# 	# 	possible to specify a redirect URL.
	# 	return		301 https://$host:<port_number_here>$request_uri;
	# }
}
